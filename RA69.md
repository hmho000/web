**红米ax6总结
1、采用高通企业级的ipq8071A处理器，性能强劲。处理器是支持双口万兆的，跑千兆完全无压力
2、cpu默认1.4G ，如果能超频到2G以上会更加完美
3、整体感觉稳定可靠
xiaomimtd12.bin文件下载：https://ac2100.lanzoul.com/b01215eji 密码:3ypa
暗云的uboot下载地址（5元）：https://mbd.pub/o/bread/YpeXk5pr

命令分段具体按视频步骤操作
一、
nvram set flag_last_success=0
nvram set flag_boot_rootfs=0
nvram set flag_boot_success=1
nvram set flag_try_sys1_failed=0
nvram set flag_try_sys2_failed=0
nvram set boot_wait=on
nvram set uart_en=1
nvram set telnet_en=1
nvram set ssh_en=1
nvram commit
二、
mtd write /tmp/xiaomimtd12.bin rootfs
三、
fw_setenv flag_last_success 0
fw_setenv flag_boot_rootfs 0
四、
mtd erase /dev/mtd1
mtd write /tmp/ax6-mibib.bin /dev/mtd1
mtd erase /dev/mtd7
mtd write /tmp/uboot-redmi-ax6.bin /dev/mtd7**

# 小米 ax6 ax3600不死uboot引导官方和QSDK互刷

云：[https://mianbaoduo.com/o/anyun/work](https://mianbaoduo.com/o/anyun/work)

志平：[https://www.right.com.cn/FORUM/thread-8253375-1-1.html](https://www.right.com.cn/FORUM/thread-8253375-1-1.html)

不管是暗云的还是志平的都可以刷官方去校验固件和QSDK

1.不死uboot+qsdk刷官方固件：先刷官方原厂mibib分区文件，重启后进uboot刷官方ubi即可

2.不死uboot+官方刷qsdk固件：先刷qsdk大分区mibib文件，重启后进uboot刷qsdk即可

ssh上传对应mibib到tmp目录

依次输入3行命令

mtd erase /dev/mtd1

mtd write /tmp/mibib.bin /dev/mtd1

reboot

先按住reset插电后等待10秒松开reset

ip固件192.168.1.2  225.225.225.0

浏览器打开192.168.1.1即可进入uboot刷固件

**前言：**

该固件主要是自己编译来家里的红米 AX6 使用的。对于自己的使用情况，需要的功能比较少，拨号上网，违禁词语打倒美帝，然后就没了。。。所以此固件集成的东西很少。需要其他插件的麻烦自行安装一下。

 **需要其他插件的麻烦自行安装一下。** 每个人的需求都会有些不同，对于我而言，就这样子就够了。也许，哪天，想试试某个插件时，便会在编译时一同编译进去，可能下一个版本就去掉。

尽可能的不添加太多的东西，酸爽乳每次都会有（这是我必须用到的）。至于其它的，大多数情况下都不会集成进去。

红米AX6 的固件，会更新的慢点。

帖子里更新不一定及时，一般云编译后，我自己回家更新了后才会同步到帖子里。着急的话，可以在 [https://github.com/hochenchong/Actions-OpenWrt/releases](https://github.com/hochenchong/Actions-OpenWrt/releases) 找一下是否有最新编译的固件

**最近自动编译的固件都是缺失了无线，源码已经有人反馈了，暂时还没修复**

**暂时照着 [https://github.com/coolsnowwolf/lede/issues/11182](https://github.com/coolsnowwolf/lede/issues/11182) 里先回滚到某个版本来编译，等待官方修复后再说了**

 **（也就是说最近编译的内核版本会一致，就集成的插件进行了更新，比如说酸爽乳支持最新的协议** **）。**

**固件说明：**

1. 编译时间：20230616
2. 内核版本：5.10.176
3. 固件版本：OpenWrt R23.5.1 / LuCI Master (git-23.163.54516-50f4225)
4. 编译的源码取自：[https://github.com/coolsnowwolf/lede](https://github.com/coolsnowwolf/lede)
5. 集成插件：酸爽乳、TTYD 终端
6. 默认主题：Argon（固件里也只包含了这个主题）
7. 默认系统后台：192.168.123.1，账号：root，密码：password

**下载链接：**

百度网盘链接：[https://pan.baidu.com/s/1zBtzdk1ERG4SYeTHu-b2lw](https://pan.baidu.com/s/1zBtzdk1ERG4SYeTHu-b2lw)

提取码：2333

**刷入方式：**

参考：[小米红米路由器AX6刷第三方openwrt固件](https://www.right.com.cn/forum/thread-4111331-1-1.html)

如果已经刷了其他的 openwrt 固件，则可以参考 [[Redmi AX6] AX6从lean的LEDE固件刷回志平的QSDK固件教程](https://www.right.com.cn/forum/thread-5326459-1-1.html)

按贴中教程，**区别在于：将第三步的 刷机包 换成网盘里 openwrt-ipq807x-generic-redmi_ax6-squashfs-nand-factory.ubi 即可**

**如果是刷的是历史版本，升级建议：**

1. 系统 - 备份/恢复 - 生成备份，下载配置的备份文件
2. 系统 - 备份/恢复 - 执行重置
3. 不保留配置，使用 openwrt-ipq807x-generic-redmi_ax6-squashfs-nand-sysupgrade.bin 升级
4. 升级之后，再使用第一步的备份文件进行恢复配置即可

 **历史版本：** 历史版本直接看网盘吧，基本上区别在于编译时间、内核版本、固件版本，对应的固件有截图信息。

关于这个固件，在 LEDE 固件里，是移除了 ax6 相关的，具体的纠纷就没去研究了，可以看这次提交：[ipq807x: drop all xiaomi devices support](https://github.com/coolsnowwolf/lede/commit/edbd8d2e9839357f3a4f0a06174d243f362b1544)

在 2022年11月时，L大又把 ax6 相关的大部分内容添加回去了。

自己编译的话，不用再回滚那次移除的提交，只用修改 target/linux/ipq807x/image/generic.mk 这个文件，添加回 ax6 的配置即可

1. define Device/redmi_ax6
2. $(call Device/xiaomi_ax3600)
3. DEVICE_VENDOR := Redmi
4. DEVICE_MODEL := AX6
5. DEVICE_PACKAGES := ipq-wifi-redmi_ax6 uboot-envtools
6. endef
7. TARGET_DEVICES += redmi_ax6

或者将 [https://github.com/hochenchong/Actions-OpenWrt/blob/main/ax6/generic.mk](https://github.com/hochenchong/Actions-OpenWrt/blob/main/ax6/generic.mk) 整个文件替换掉 target/linux/ipq807x/image/generic.mk 即可。

自己的云编译项目，就是直接替换掉这个文件

1. cp -rf $GITHUB_WORKSPACE/ax6/generic.mk openwrt/target/linux/ipq807x/image/generic.mk

## b站上 up主是真的强

Redmi AX6 的三种固件布局分别代表不同的固件设计或用途，以下是它们的含义和特点：

---

### 1. **自定义 U-Boot 布局 (Custom U-Boot Layout)**

 **定义** ：修改了设备的原始 U-Boot（路由器的引导程序）布局，用于实现更多功能或适配特定固件。

 **特点** ：

* 可以灵活引导不同固件（例如 OpenWrt、ImmortalWrt 或原厂固件）。
* 支持多种引导方式（TFTP、串口等），方便调试或恢复。
* 通常扩展了闪存分区的灵活性，可以为系统固件和存储分配更多空间。

 **适用场景** ：

* 高级用户希望定制引导程序，以便更好地管理路由器。
* 需要兼容多个固件或恢复系统。

---

### 2. **OpenWrt 扩展布局 (OpenWrt Expand Layout)**

 **定义** ：这是基于 OpenWrt 的自定义分区布局，优化闪存分区以提升固件的功能和存储空间利用率。

 **特点** ：

* 修改了原厂闪存分区，将更多空间分配给 rootfs（根文件系统）。
* 可以安装更多 OpenWrt 插件，如 Samba、Adblock 或 VPN。
* 通常将原厂固件的部分功能裁剪掉（例如保留恢复分区，移除其他无用的功能分区）。

 **适用场景** ：

* 用户以 OpenWrt 为主，注重可扩展性和功能增强。
* 适合运行大规模插件或复杂的网络环境。

---

### 3. **原厂布局 (Stock Layout)**

 **定义** ：设备出厂时的默认分区和固件布局，完全保留小米官方提供的功能和设计。

 **特点** ：

* 保持小米路由器的官方特性和管理界面。
* 分区结构较固定，用户自定义扩展性较差。
* 一般保留原厂恢复功能（如通过官方 Web 界面恢复固件）。

 **适用场景** ：

* 普通用户只需要基本功能（如家庭 WiFi 和简单的网络设置）。
* 不需要运行第三方固件或自定义配置。

---

### 总结

| 布局类型           | 灵活性 | 功能扩展性 | 操作难度 | 推荐用户     |
| ------------------ | ------ | ---------- | -------- | ------------ |
| 自定义 U-Boot 布局 | 高     | 高         | 高       | 高级用户     |
| OpenWrt 扩展布局   | 中     | 高         | 中       | OpenWrt 用户 |
| 原厂布局           | 低     | 低         | 低       | 普通用户     |

我现在是分区表

root@OpenWrt:~# cat /proc/mtd
dev:    size   erasesize  name
mtd0: 00100000 00020000 "0:sbl1"
mtd1: 00100000 00020000 "0:mibib"
mtd2: 00300000 00020000 "0:qsee"
mtd3: 00080000 00020000 "0:devcfg"
mtd4: 00080000 00020000 "0:rpm"
mtd5: 00080000 00020000 "0:cdt"
mtd6: 00080000 00020000 "0:appsblenv"
mtd7: 00100000 00020000 "0:appsbl"
mtd8: 00080000 00020000 "0:art"
mtd9: 00080000 00020000 "bdata"
mtd10: 00080000 00020000 "crash"
mtd11: 00080000 00020000 "crash_syslog"
mtd12: 023c0000 00020000 "rootfs"
mtd13: 023c0000 00020000 "rootfs_1"
mtd14: 01ec0000 00020000 "overlay"
mtd15: 00080000 00020000 "rsvd0"

从你的分区布局来看，Redmi AX6 的闪存被分为多个小分区，其中一些是系统关键分区，另一些是用于存储操作系统（OpenWrt 或其他固件）的分区。以下是关键分区的解释和如何调整它们的建议：

---

### **分区布局分析**

| 分区名称                | 大小   | 说明                                                                 |
| ----------------------- | ------ | -------------------------------------------------------------------- |
| `mtd0-mtd7`           | 小分区 | 各种引导相关分区（如 SBL1、QSEE、Appsbl），负责设备启动过程。        |
| `mtd8`(`art`)       | 512 KB | 保存 WiFi 射频校准数据（非常重要，切勿删除）。                       |
| `mtd9`(`bdata`)     | 512 KB | 保存设备硬件信息（如 MAC 地址、序列号等）。                          |
| `mtd12`(`rootfs`)   | 36 MB  | 主系统分区，用于存储运行的 OpenWrt 文件系统。                        |
| `mtd13`(`rootfs_1`) | 36 MB  | 备用系统分区，原厂固件用于双分区冗余更新机制，OpenWrt 中通常未用到。 |
| `mtd14`(`overlay`)  | 31 MB  | 用户存储分区，用于保存配置和插件（在 OpenWrt 中作为 `/overlay`）。 |
| `mtd15`(`rsvd0`)    | 512 KB | 保留分区，可能存放日志或调试信息。                                   |

---

### **调整分区的目的**

1. **释放备用分区空间 (`rootfs_1`)：**
   * 备用分区（`rootfs_1`）在 OpenWrt 中通常未被使用。可以将其与主分区合并，增加系统存储空间。
2. **增大 Overlay 分区：**
   * `/overlay` 是用户存储分区，空间较小（31 MB）。扩展此分区可以容纳更多插件和配置。
3. **保留重要分区：**
   * 例如 `art` 和 `bdata`，这些分区对路由器硬件功能至关重要，切勿覆盖或删除。

---

### **修改分区布局的步骤**

#### **1. 备份重要分区**

在调整分区之前，先备份重要分区数据：

```bash
mkdir /tmp/backup
for part in /dev/mtd{0..15}; do
    dd if=$part of=/tmp/backup/$(basename $part).bin
done
```

将备份文件传输到本地：

```bash
scp /tmp/backup/*.bin user@<你的电脑IP>:~/router_backup/
```

#### **2. 修改分区表**

**方法 1：通过设备树文件（DTS）调整分区**

1. 提取当前设备树：
   ```bash
   dtc -I fs -O dts /sys/firmware/devicetree/base > /tmp/current.dts
   ```
2. 编辑 `/tmp/current.dts` 文件，找到 `partitions` 节点，调整 `rootfs` 和 `rootfs_1` 的大小。例如：
   ```dts
   partition@c00000 {
       label = "rootfs";
       reg = <0xc00000 0x47c0000>; // 增大 rootfs 大小
   };
   partition@53c0000 {
       label = "overlay";
       reg = <0x53c0000 0x4ec0000>; // 将 rootfs_1 合并到 overlay
   };
   ```
3. 重新编译 DTS 并应用：
   ```bash
   dtc -I dts -O dtb /tmp/current.dts > /tmp/new.dtb
   cp /tmp/new.dtb /boot/devicetree.dtb
   ```

**方法 2：直接修改内核分区映射**

1. 编辑 `/etc/config/fstab` 或挂载脚本：
   * 合并 `rootfs_1` 到主分区。
   * 重新挂载 `/overlay`，扩展其空间。
   * 确保新的挂载生效后重启。

---

### **注意事项**

* **双分区机制：** 修改后可能丧失原厂固件的双分区更新功能。
* **校准数据保护：** 确保 `art` 和 `bdata` 不被改动，否则会导致无线或硬件功能异常。
* **恢复手段：** 在操作前准备好 TTL 串口工具，以防设备变砖。

root@OpenWrt:~# fw_printenv
bootcmd=tftp
bootdelay=5
SN=29164/A0UA39193
ethaddr="00:AA:BB:CC:DD:10"
ipaddr=192.168.31.1
serverip=192.168.31.100
stdin=serial
stdout=serial
stderr=serial
uart_en=1
telnet_en=0
wl0_ssid=Redmi_D6C1_293E_5G
wl1_ssid=Redmi_D6C1_293E
wl0_radio=1
wl1_radio=1
boot_wait=on
flag_boot_rootfs=0
no_wifi_dev_times=0
flag_boot_type=2
CountryCode=CN
flag_last_success=0
flag_ota_reboot=0
color=100
miot_did=484246315
miot_key=yKxCLBTdN45gLzUv
nv_wan_type=
flag_boot_success=1
flag_try_sys1_failed=0
flag_try_sys2_failed=0
nv_pppoe_name=13562990459
nv_pppoe_pwd=906875
Router_unconfigured=0
mode=AP
model=RA69
nv_sys_pwd=efc9ff38a393c58197c8ebda78c3ad6d61fb25c7
nv_wifi_ssid=54188@DD.com
nv_wifi_enc=mixed-psk
nv_wifi_pwd=dsc770556
nv_wifi_ssid1=54188@DD.com
nv_wifi_enc1=mixed-psk
nv_wifi_pwd1=dsc770556
flag_show_upgrade_info=0
restore_defaults=0
ssh_en=1

看来降级 把两个分区都变成了 有后门的系统

nvram get flag_last_success      检查上次启动成功？

我是这个分区 0  那么我在什么分区  我的降级固件在 13分区

********** 如果返回分区数字为0，请执行下面操作：**********
1、切换当前启动的系统分区为13分区
     nvram set flag_last_success=1
     nvram set flag_boot_rootfs=1
     nvram commit
     reboot
2、在Winscp中上传OP固件到路由器的/tmp目录
3、刷入OP固件并切换启动分区：
     ① 登录SSH：ssh root@192.168.31.1
     ② 刷入OP固件 ubiformat /dev/mtd12 -y -f /tmp/你上传的固件文件名
     ③ 切换启动分区为13分区；                应该到12分区启动
	nvram set flag_last_success=0
	nvram set flag_boot_rootfs=0
	nvram commit
	reboot

OP切换到小米系统
fw_setenv  flag_last_success 1
fw_setenv flag_boot_rootfs 1
reboot

小米系统切换到OP
nvram set flag_last_success=0
nvram set flag_boot_rootfs=0
nvram commit
reboot

---

## 备份 分区

 strings /dev/mtd12 | grep -i openwrt
ARM64 OpenWrt FIT (Flattened Image Tree)
ARM64 OpenWrt Linux-5.10.176
ARM64 OpenWrt redmi_ax6 device tree blob
OpenWrt redmi_ax6

fSopenwrt_releaseIBmEJb
openwrt_release
openwrt_releaseIBmEJb
openwrt_releaseeIigdF
openwrt_release
openwrt_releaseeIigdF
OpenWrt9e633aab
openwrt_release
DISTRIB_ID='OpenWrt'
DISTRIB_DESCRIPTION='OpenWrt '
OpenWrt9e633aab
openwrt_releasemILeef
openwrt_release
openwrt_releasemILeef
openwrt_releaseMjlcFb
8Mopenwrt_release
1openwrt_releaseMjlcFb
DISTRIB_ID='OpenWrt'
DISTRIB_DESCRIPTION='OpenWrt

---

### **关键标志位解释**

1. **引导分区标志位**
   * `flag_boot_rootfs=0`: 当前启动的分区为 `mtd12`（`rootfs`），这是你的 OpenWrt 分区。
   * `flag_last_success=0`: 上次成功启动的是 `mtd12` 分区。
   * `flag_try_sys1_failed=0`: 表示没有尝试失败的记录（与 `mtd12` 分区相关）。
   * `flag_try_sys2_failed=0`: 表示没有尝试失败的记录（与 `mtd13` 分区相关）。
2. **其他标志位**
   * `bootcmd=tftp`: 默认引导命令（如果你需要恢复或刷机时使用 TFTP）。
   * `uart_en=1` 和 `ssh_en=1`: 表示串口和 SSH 已解锁，可以自由使用这两种方式进行调试或管理。
   * `flag_boot_type=2`: 系统的启动类型标志，与原厂更新机制相关。
3. **当前环境**
   * 你的路由器当前运行 OpenWrt，并且从 `mtd12`（`rootfs`）分区启动。
   * 原厂固件可能仍保留在 `mtd13`（`rootfs_1`）。

---

### **如何切换到原厂固件（`mtd13`）**

如果你需要切换到原厂固件所在的分区（`mtd13`），可以通过以下步骤实现：

```bash
fw_setenv flag_last_success 1
fw_setenv flag_boot_rootfs 1
reboot
```

执行以上命令后，路由器将重启并从 `mtd13` 分区（原厂固件）启动。

---

### **如何切换回 OpenWrt（`mtd12`）**

当需要切换回 OpenWrt 分区（`mtd12`）时，执行以下命令：

```bash
fw_setenv flag_last_success 0
fw_setenv flag_boot_rootfs 0
reboot
```

设备将重启并加载 `mtd12` 的 OpenWrt 系统。

---

### **其他操作建议**

#### **1. 备份当前配置**

无论你是否修改配置，建议先备份当前环境，以防操作错误导致无法恢复：

```bash
mkdir -p /tmp/backup
fw_printenv > /tmp/backup/fw_env.txt
dd if=/dev/mtd8 of=/tmp/backup/mtd8_nvram.bin
scp -r /tmp/backup user@<你的电脑IP>:~/router_backup/
```

#### **2. 确认分区状态**

通过检查分区内容来确保每个分区的用途：

```bash
strings /dev/mtd12 | grep -i openwrt
strings /dev/mtd13 | grep -i xiaomi
```

这可以帮助你确认 `mtd13` 是否还存有原厂固件。

#### **3. 刷写固件**

如果你需要在任何分区刷入新的固件，例如将 OpenWrt 刷到 `mtd13`，可以按以下步骤操作：

1. 上传固件到 `/tmp` 目录：
   ```bash
   scp openwrt-firmware.bin root@192.168.31.1:/tmp/
   ```
2. 刷写到 `mtd13`：
   ```bash
   ubiformat /dev/mtd13 -y -f /tmp/openwrt-firmware.bin
   ```
3. 切换启动到 `mtd13`：
   ```bash
   fw_setenv flag_last_success 1
   fw_setenv flag_boot_rootfs 1
   reboot
   ```

从输出信息来看，`/dev/mtd13` 的数据包含了一些可读的标识符（例如 `UBI#`、`UBI!`、`kernel`、`ubi_rootfs` 等），也有一些混乱的二进制数据和字符。这表明该分区可能是一个  **UBI（Unsorted Block Image）格式的 NAND 分区** ，里面包含压缩或加密的数据。

### 判断是否加密的方法

1. **UBI 格式** ：UBI 是一种管理 NAND 闪存的文件系统格式，可以存储原始文件系统（如 SquashFS）或其他类型的数据。若数据是以加密形式存储的，解压后仍可能是不可读的。
2. **检查文件系统** ：

* 可以尝试使用工具挂载分区或者提取内容。例如：

  ```bash
  ubiattach /dev/ubi_ctrl -m 13
  mount -t ubifs /dev/ubi0_0 /mnt
  ```

  如果挂载成功并能访问内容，说明数据未加密。
* 如果无法挂载，可能是因为文件系统未识别或已加密。

1. **解密特征** ：

* 文件内容中没有明显的字符串（如配置文件、脚本等）。
* 数据多呈现高熵（混乱、随机）状态，这是加密数据的典型特征。

1. **尝试解压 SquashFS** ：
   若分区是压缩而非加密的，可以使用 `unsquashfs` 工具：

```bash
   unsquashfs -d ./output /dev/mtd13
```

   如果成功提取内容，说明数据未加密。

1. **查看 U-Boot 配置** ：
   有时设备会在 U-Boot 阶段启用分区加密（如使用 AES）。可以检查是否有加密机制配置在固件中。

### 下一步建议

* **备份分区数据** ：先用 `dd` 备份分区内容。

```bash
  dd if=/dev/mtd13 of=backup_mtd13.img
```

* **分析备份文件** ：在备份的基础上进一步实验，避免破坏原始数据。
* **检查设备文档** ：查阅相关文档，看是否有提到分区加密或文件系统的详细信息。
* **工具尝试** ：用 `binwalk` 或 `strings` 更深入分析。

```bash
  binwalk -e backup_mtd13.img
```

  该工具可以识别压缩类型或加密类型。

Uboot刷机：

1、刷入临时OP固件为合并分区做准备（参照扩容刷机的第二步）

2、使用winscp把 ax6-minbib.bin 以及 uboot-redmi-ax6.bin 上传到路由器tmp目录

3、输入下面命令刷入扩容分区表、刷入改版uboot

    mtd erase /dev/mtd1
     mtd write /tmp/ax6-mibib.bin /dev/mtd1

    mtd erase /dev/mtd7
     mtd write /tmp/uboot-redmi-ax6.bin /dev/mtd7

4、拔电源重启

我要扩容了

扩容刷入uboot 成功

如果光猫使用 **SLAAC（无状态地址自动配置）** 来分发 IPv6 地址，那么 OpenWrt 的配置需要特别调整，因为 SLAAC 的工作机制与 DHCPv6-PD 不同。以下是详细的配置步骤和注意事项：

---

### SLAAC 工作原理

* SLAAC 是基于路由器通告（RA，Router Advertisement）的协议。
* 光猫通过发送 RA 报文告知网络中的设备如何自动生成 IPv6 地址。
* OpenWrt 需要配置为接收 RA 报文，并基于 SLAAC 自动生成 IPv6 地址。

---

### 配置步骤

#### 1. 检查 OpenWrt WAN 接口设置

确保 OpenWrt 的 WAN 接口能够接收 SLAAC 地址：

1. 登录 OpenWrt 管理界面，进入  **网络 -> 接口 -> WAN** 。
2. 检查 WAN 的协议类型：
   * 如果协议为 `DHCPv6`，请改为 `IPv6（仅客户端）` 或类似选项。
   * 如果没有此选项，可以尝试使用 `DHCPv6` 协议，并确保以下选项已启用：
     * **接收路由通告（Accept RA）** ：启用。
     * **请求地址（Request Address）** ：启用。
3. 保存并应用。

#### 2. LAN 接口配置

SLAAC 模式下，LAN 接口的 IPv6 地址会基于光猫下发的 RA 报文自动生成：

1. 进入  **网络 -> 接口 -> LAN** 。
2. 确保以下设置正确：
   * **IPv6 分发：** 启用。
   * **DHCPv6 模式：** 选择 `服务器和中继` 或 `中继`。
3. 保存并应用。

---

#### 3. 防火墙设置

确保防火墙允许 IPv6 数据包转发：

1. 进入  **网络 -> 防火墙 -> 区域设置** ：
   * 确保 `LAN` 和 `WAN` 区域启用了 IPv6 转发。
2. 添加自定义规则（可选）：
   ```bash
   ip6tables -A FORWARD -i br-lan -o eth2 -j ACCEPT
   ip6tables -A FORWARD -i eth2 -o br-lan -j ACCEPT
   ```

---

#### 4. 检查路由器是否接收 RA 报文

使用以下命令检查 WAN 接口是否接收到光猫的 RA 报文：

```bash
tcpdump -i eth2 icmp6 and ip6[40] == 134
```

输出中应该包含来自光猫的 RA 报文。如果没有，则可能是：

* 光猫未启用 SLAAC。
* 防火墙规则阻止了 RA 报文。

---

#### 5. 验证 IPv6 地址

1. 检查 WAN 接口的 IPv6 地址：

   ```bash
   ip -6 addr show eth2
   ```

   * 应该看到基于光猫的前缀生成的 IPv6 地址（例如 `2408::/64`）。
2. 检查 LAN 接口是否分发了 SLAAC 地址：

   ```bash
   ip -6 addr show br-lan
   ```
3. 确认内网设备是否能获取到 SLAAC 地址：

   * 在内网设备上运行：
     ```bash
     ip -6 addr show
     ```

---

### 解决常见问题

#### 1. 无法获取 SLAAC 地址

* 检查光猫是否启用了 SLAAC。
* 确保 OpenWrt 的 WAN 接口启用了  **接受 RA** 。
* 检查防火墙规则是否允许 RA 报文通过。

#### 2. 内网设备无法获取 IPv6 地址

* 确保 LAN 接口已启用 IPv6 分发。
* 检查路由器是否正确接收光猫的 RA，并转发到 LAN。

#### 3. 排查日志

使用以下命令查看 OpenWrt 的 IPv6 配置和日志：

```bash
logread | grep odhcpd
logread | grep ra
```

---

fsku4VhmX-GtC27OIFcehXS5GXChiyXD_O9dQtSs

DDNS

ddns

ipv6.ftyiming.us.kg

在 OpenWrt 中，`/etc/opkg/customfeeds.conf` 和 `/etc/opkg/distfeeds.conf` 是两个用于配置软件包源的文件，它们的作用和用途有所不同：

---

### 1. **`/etc/opkg/distfeeds.conf`**

* **用途** :

  这是 OpenWrt 官方维护的默认软件包源配置文件。它包含官方版本发布时预设的源地址，通常指向 OpenWrt 的官方服务器或镜像站。
* **内容** :

  通常定义了各类官方软件包源，如 `core`、`base`、`luci`、`packages` 等。例如：

```plaintext
  src/gz openwrt_core https://downloads.openwrt.org/releases/23.05.0/targets/qualcommax/ipq807x/packages
  src/gz openwrt_base https://downloads.openwrt.org/releases/23.05.0/packages/aarch64_cortex-a53/base
  src/gz openwrt_luci https://downloads.openwrt.org/releases/23.05.0/packages/aarch64_cortex-a53/luci
```

* **修改建议** :

  不建议直接修改该文件，因为它可能会在固件升级或系统更新时被覆盖。

---

### 2. **`/etc/opkg/customfeeds.conf`**

* **用途** :

  这是一个自定义的配置文件，用户可以在此文件中添加第三方源或自定义的包源地址，扩展软件包安装的能力。
* **内容** :

  通常用于添加非官方的软件包源。例如：

```plaintext
  src/gz custom_feed https://example.com/openwrt/packages
  src/gz my_feed https://myserver.com/openwrt/custom-packages
```

* **修改建议** :

  用户可以自由编辑或添加内容，不会因为固件升级而被覆盖，适合放置个人维护的源或第三方源地址。

---

### 3. **两者的关系**

* **优先级** :

  两个文件中的源地址具有相同的优先级，`opkg` 会依次查询所有定义的源地址。
* **用途划分** :
* `distfeeds.conf` 适用于官方维护的源。
* `customfeeds.conf` 适用于用户自定义的第三方源。

例如：

* 官方源配置放在 `distfeeds.conf`。
* 第三方插件源（如 SSR+）配置放在 `customfeeds.conf`。

---

### 4. **如何管理这两个文件**

* 如果只需修改官方源地址（如更换镜像站），编辑 `distfeeds.conf`。
* 如果需添加新的包源或第三方源，建议将其放在 `customfeeds.conf`，以便管理和维护。

---

### 5. **实际应用建议**

在实际使用中：

1. **更换镜像站** :
   如果只是将源替换为镜像站（如 TUNA），直接修改 `distfeeds.conf`：

```bash
   sed -i 's|https://downloads.openwrt.org|https://mirrors.tuna.tsinghua.edu.cn/openwrt|' /etc/opkg/distfeeds.conf
```

1. **添加第三方源** :
   将第三方源添加到 `customfeeds.conf`：

```bash
   echo 'src/gz custom_feed https://example.com/openwrt/packages' >> /etc/opkg/customfeeds.conf
```

通过这种方式，可以更清晰地管理官方源和自定义源的配置。

ALG（Application Layer Gateway）是一种在路由器或防火墙中用来确保某些应用层协议能够在 NAT（网络地址转换）环境下正常运行的功能。不同的 ALG 功能对应不同的协议，用于解析和处理这些协议中的嵌入式 IP 地址或端口信息。

以下是各个选项的作用和建议：

1. **启用 L2TP ALG**
   * **作用** ：用于处理 L2TP（Layer 2 Tunneling Protocol）隧道协议，确保 VPN 连接能通过 NAT。
   * **建议** ：如果使用 L2TP VPN，则勾选；否则可以关闭。
2. **启用 IPSec ALG**
   * **作用** ：为 IPSec（Internet Protocol Security）提供 NAT 穿越支持，处理 ESP（Encapsulation Security Payload）和 IKE（Internet Key Exchange）数据。
   * **建议** ：如果使用 IPSec VPN，则勾选；否则关闭。
3. **启用 H.323 ALG**
   * **作用** ：H.323 是一种用于视频会议、VoIP 等的协议，ALG 支持可确保这些服务在 NAT 环境中正常工作。
   * **建议** ：如果使用 H.323 的视频或音频服务，则勾选；否则关闭。
4. **启用 RTSP ALG**
   * **作用** ：为 RTSP（Real Time Streaming Protocol）提供支持，确保实时流媒体传输在 NAT 环境中能正确处理端口。
   * **建议** ：如果经常使用流媒体服务（如监控设备或视频播放），勾选；否则关闭。
5. **启用 SIP ALG**
   * **作用** ：为 SIP（Session Initiation Protocol）提供支持，确保 VoIP 呼叫可以通过 NAT。
   * **建议** ：很多情况下 SIP ALG 可能导致 VoIP 问题，除非明确需要，否则关闭。
6. **启用 FTP ALG**
   * **作用** ：为 FTP（File Transfer Protocol）提供支持，解决主动 FTP 在 NAT 环境下的连接问题。
   * **建议** ：如果需要使用主动 FTP，则勾选；否则关闭。
7. **启用 PPTP ALG**
   * **作用** ：为 PPTP（Point-to-Point Tunneling Protocol）VPN 提供 NAT 穿越支持。
   * **建议** ：如果使用 PPTP VPN，则勾选；否则关闭。

---

### 总结：

是否需要启用 ALG 取决于你具体的网络使用场景。如果某些应用或服务在 NAT 环境下无法正常工作，可以尝试勾选相应的 ALG 功能。但 **不建议全选** ，因为开启不必要的 ALG 可能导致性能下降或意外的网络问题。

如需进一步优化网络性能，建议：

1. 尽量使用 UPnP 或手动端口映射替代 ALG。
2. 检查使用的具体协议，针对性地开启相关选项。

切换80端口到5680 LuCI - OpenWrt Configuration Interface

vi /etc/config/uhttpd

/etc/init.d/uhttpd restart

在 OpenWrt 上配置自签名 SSL 证书并通过 56443 端口访问 HTTPS，可以按照以下步骤操作：

---

### 1. **生成自签名 SSL 证书**

1. 使用 SSH 登录到路由器。

   ```bash
   ssh root@192.168.1.1
   ```
2. 检查是否安装了 `openssl` 工具包：

   ```bash
   opkg update
   opkg install openssl-util
   ```
3. 生成自签名证书和私钥：

   ```bash
   mkdir -p /etc/ssl/private
   openssl req -x509 -newkey rsa:2048 -keyout /etc/ssl/private/luci.key -out /etc/ssl/private/luci.crt -days 365 -nodes -subj "/C=CN/ST=State/L=City/O=Organization/OU=Unit/CN=OpenWrt"
   ```

   * `/etc/ssl/private/luci.key` 是私钥文件。
   * `/etc/ssl/private/luci.crt` 是证书文件。
   * `-days 365` 设置证书有效期为 1 年。

---

### 2. **配置 uhttpd 使用 SSL 和 56443 端口**

1. 编辑 `uhttpd` 配置文件：

   ```bash
   vi /etc/config/uhttpd
   ```
2. 修改或添加以下内容：

   ```plaintext
   option listen_https '0.0.0.0:56443'
   option cert '/etc/ssl/private/luci.crt'
   option key '/etc/ssl/private/luci.key'
   ```

   如果你希望仅启用 HTTPS，可以注释或删除 `option listen_http` 的配置行。
3. 保存并退出（按 `ESC` 键，然后输入 `:wq`）。

---

### 3. **重启 uhttpd 服务**

执行以下命令以应用更改：

```bash
/etc/init.d/uhttpd restart
```

---

### 4. **通过 HTTPS 访问 LuCI**

在浏览器中输入：

```plaintext
https://<路由器IP>:56443
```

例如：

```plaintext
https://192.168.1.1:56443
```

---

### 5. **解决浏览器安全警告（可选）**

由于自签名证书不是由受信任的 CA 签发，浏览器会提示“不安全”或显示安全警告。你可以选择手动信任证书：

1. 点击浏览器的高级选项。
2. 选择“继续访问”或将证书添加到系统的信任列表中（浏览器具体操作因品牌而异）。

---

完成后，你应该能够通过 HTTPS 和 56443 端口安全访问 LuCI 管理界面。

logread | grep uhttpd | less

```
uci set zerotier.global.enabled='1'
uci delete zerotier.earth
uci set zerotier.mynet=network
uci set zerotier.mynet.id=<abfd31bd47eb4d4a>
uci commit zerotier
service zerotier restart
```

AX6NSS-qualcommax-6.x-nss-wifi

现在用的这个固件

Actions-Redmi-AX6  一周构建一次

这些 OpenWrt 固件文件适用于  **Redmi AX6** （ **IPQ8071A** ），主要区别如下：

### 1. **initramfs vs squashfs**

* **initramfs** ：临时运行的 RAMDisk 固件，适用于测试或解锁后首次刷入（通常不带持久化存储）。
* **squashfs** ：带有 **只读根文件系统** 的标准 OpenWrt 固件，适用于长期使用。

### 2. **factory vs sysupgrade**

* **factory** ：用于**从原厂固件刷入 OpenWrt** 或  **通过 U-Boot TFTP 恢复刷机** ，通常是 **.ubi** 格式。
* **sysupgrade** ：用于  **已有 OpenWrt 的设备升级** ，格式一般为  **.bin** 。

### 3. **文件具体作用**

| 文件名                                                           | 说明                                   | 适用场景                                                               |
| ---------------------------------------------------------------- | -------------------------------------- | ---------------------------------------------------------------------- |
| `openwrt-qualcommax-ipq807x-redmi_ax6-initramfs-factory.ubi`   | **工厂版 initramfs 固件**        | **解锁后临时启动 OpenWrt** （用于解锁 SSH 或进入 OpenWrt）       |
| `openwrt-qualcommax-ipq807x-redmi_ax6-initramfs-uImage.itb`    | **initramfs 运行的 uImage 固件** | U-Boot 或某些特殊引导方式使用                                          |
| `openwrt-qualcommax-ipq807x-redmi_ax6-squashfs-factory.ubi`    | **工厂版 squashfs 固件**         | **从原厂固件刷入 OpenWrt** （通过 U-Boot TFTP 或 Web 恢复）      |
| `openwrt-qualcommax-ipq807x-redmi_ax6-squashfs-sysupgrade.bin` | **sysupgrade 版 squashfs 固件**  | **已刷 OpenWrt 后的升级** （通过 `sysupgrade`指令或 Web 升级） |
| `openwrt-qualcommax-ipq807x-redmi_ax6.manifest`                | 该版本的固件**包含的软件包列表** | 仅用于参考，不是刷机文件                                               |

---

### **你该怎么选？**

* **从原厂刷 OpenWrt（首次刷机）** → `openwrt-qualcommax-ipq807x-redmi_ax6-squashfs-factory.ubi`
* **临时启动 OpenWrt（测试/解锁）** → `openwrt-qualcommax-ipq807x-redmi_ax6-initramfs-factory.ubi`
* **已经是 OpenWrt，想升级** → `openwrt-qualcommax-ipq807x-redmi_ax6-squashfs-sysupgrade.bin`

如果你是 **第一次刷 OpenWrt** ，通常需要 `factory.ubi` 文件，并使用 TFTP 方式刷入。

备份一下 设置 看看保留设置怎么样  不保留了

`192.168.2.1` 无密码

* (更新)因为内存导致的luci卡死问题似乎修复了(至少我开机好几天没见luci崩溃了)，~~不过由于5.15内核源码的原因，开不了160Mhz~~
* (再次更新)若要开160Mhz请在网络-无线项目找到Generic 802.11acaxn，点击编辑，将信道设置成48(亲测可用，也可以尝试其它信道)，然后在高级设置下把国家设置为US - United States，保存并应用设置，等待一分钟左右即可

![1738290640756](RA69/1738290640756.png)

还是虚拟wan口

* 浏览器进入192.168.1.1，刷入***-initramfs-factory.ubi
* 改回DHCP，进入路由器后台，按照[如何更新固件](tutorial/ru-he-geng-xin-gu-jian.md)刷入***-squashfs-sysupgrade.bin

不支持 卧槽 那我uboot 去192.168.1.1

dH6tN$5z)ec5m$a

LEAD 的固件还是192.168.1.1

可以进去

## DDNS

Custom update URL

https://api.cloudflare.com/client/v4/user/tokens/verify

# https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records/5edce1126269d157a5b75f8fda1c384f

ZONE_ID 和 RECORD_ID 可以通过 Cloudflare API 或通过 Cloudflare 的控制台找到：

ZONE_ID: 在 Cloudflare 仪表盘点击你域名的页面，URL 中包含的 zone 后面的长字符串即为 ZONE_ID。 d3fec629e04c52c5d7923afaa6654ef0

RECORD_ID: 在 DNS 设置页面中找到你需要更新的记录，通过 API 或者 UI 来查看此 ID。

```
17d971746d20de8f4cd3112dbb11d3b6
```

![1738378178405](RA69/1738378178405.png)

Username: 输入你的 Cloudflare 注册邮箱地址。  ftyiming@outlook.com

Password: 输入你刚刚创建的 API Token。  72d081643cf1927faff51db53fd71e6bfed23

ipv6.ftyiming.us.kg

改一下url获取ipv6

手动测试 Cloudflare API

curl -X GET "https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records/d3fec629e04c52c5d7923afaa6654ef0"
    -H "X-Auth-Email: ftyiming@outlook.com"
    -H "X-Auth-Key: 72d081643cf1927faff51db53fd71e6bfed23"
    -H "Content-Type: application/json"

* **如果返回 `200` 并且有 DNS 记录信息，说明 API Key 正确。**
* **如果返回 `403`，说明 API Key 不对，或者权限不足。**
* **如果返回 `404`，说明 DNS 记录 ID (`17d971746d20de8f4cd3112dbb11d3b6`) 不对。**

root@LEDE:~# curl -X GET "https://api.cloudflare.com/client/v4/user/tokens/verify" \

> -H "Authorization: Bearer GM98a5m6M7rNKMWu31AU3nx5tfRJi4yGZLuwDFmn"
> -H "Content-Type:application/json"
> {"result":{"id":"3ec2586fb881fbe8a402d4bab4a90bf6","status":"active","expires_on":"2025-10-11T23:59:59Z"},"success":true,"errors":[],"messages":[{"code":10000,"message":"This API Token is valid and active","type":null}]}root@LEDE:~#

好的，这是根据您提供的信息编写的日志：

## 动态 DNS (DDNS) 更新日志

dnsid 5edce1126269d157a5b75f8fda1c384f

**日期:** 2025-02-04

**时间:** 03:05

**设备:** (此处填写您的设备名称或型号)

**DDNS 服务:** Cloudflare

**域名:** ftyiming.us.kg (IPv6)

### 日志详情

* 03:00 - DDNS 客户端启动，尝试更新 DNS 记录。
* 03:00 - 03:02 - 由于 `nslookup` 命令无法解析域名 ftyiming.us.kg，更新尝试失败。错误信息：“BusyBox nslookup error: '1'”。
* 03:02 - 重新配置 DDNS 客户端，调整重试间隔和次数。
* 03:05 - DDNS 客户端成功检测到新的 IPv6 地址：`2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee`。
* 03:05 - DDNS 客户端使用 `wget` 命令连接到 Cloudflare API，成功更新 DNS 记录。
* 03:05 - DDNS 更新完成，状态显示为“成功”。

### 问题分析

* 最初的更新失败是由于 `nslookup` 命令无法解析域名。这可能是由于网络连接问题、DNS 服务器故障或防火墙阻止 DNS 请求等原因造成的。
* 重新配置 DDNS 客户端后，问题得到解决。可能是由于网络连接恢复正常，或者 DDNS 客户端使用了备用的 DNS 服务器。
* 最终的更新尝试使用 `wget` 命令直接与 Cloudflare API 通信，绕过了 `nslookup` 命令，因此成功完成。

### 结论

本次 DDNS 更新过程虽然遇到了一些问题，但最终成功完成。建议定期检查 DDNS 客户端的配置和日志，以确保 DNS 记录始终保持最新。

### 备注

* 本次日志记录了 IPv6 地址的更新过程。
* 您可以根据实际情况修改日志内容，例如添加设备信息、故障排除步骤等。

希望这份日志对您有所帮助！

nslookup 出错是因为 wan口没配置dns 和 网关

![1739079453315](RA69/1739079453315.png)

自定义 链接 https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records/d3fec629e04c52c5d7923afaa6654ef0

密码   value="GM98a5m6M7rNKMWu31AU3nx5tfRJi4yGZLuwDFmn"

030253  WARN : Get registered/public IP for 'ipv6.ftyiming.us.kg' failed after 1 retries - TERMINATE
 030253  WARN : PID '16718' exit WITH ERROR '1' at 2025-02-04 03:02
 030503       : ************ ************** ************** **************
 030503  note : PID '17545' started at 2025-02-04 03:05
 030503       : ddns version  : 2.8.2-52
 030503       : uci configuration:
ddns.myddns_ipv6.check_interval='1'
ddns.myddns_ipv6.check_unit='hours'
ddns.myddns_ipv6.domain='ftyiming.us.kg'
ddns.myddns_ipv6.enabled='1'
ddns.myddns_ipv6.force_interval='24'
ddns.myddns_ipv6.force_unit='hours'
ddns.myddns_ipv6.interface='wan6'
ddns.myddns_ipv6.ip_network='wan6'
ddns.myddns_ipv6.ip_source='network'
ddns.myddns_ipv6.lookup_host='ipv6.ftyiming.us.kg'
ddns.myddns_ipv6.password='***PW***'
ddns.myddns_ipv6.retry_interval='5'
ddns.myddns_ipv6.retry_max_count='1'
ddns.myddns_ipv6.retry_unit='seconds'
ddns.myddns_ipv6.update_url='https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records/d3fec629e04c52c5d7923afaa6654ef0'
ddns.myddns_ipv6.use_ipv6='1'
ddns.myddns_ipv6.use_syslog='2'
ddns.myddns_ipv6.username='ftyiming@outlook.com'
ddns.myddns_ipv6=service
 030503       : verbose mode  : 0 - run normal, NO console output
 030503       : check interval: 3600 seconds
 030503       : force interval: 86400 seconds
 030503       : retry interval: 5 seconds
 030503       : retry max count : 1 times
 030503       : No old process
 030503       : last update: never
 030503       : Detect registered/public IP
 030503       : #> /usr/bin/nslookup ipv6.ftyiming.us.kg  >/var/run/ddns/myddns_ipv6.dat 2>/var/run/ddns/myddns_ipv6.err
 030504       : Registered IP '2409:8a3c:5b60:c670::2' detected
 030504  info : Starting main loop at 2025-02-04 03:05
 030504       : Detect current IP on 'network'
 030504       : Current IP '2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee' detected on network 'wan6'
 030504       : Update needed - L: '2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee' <> R: '2409:8a3c:5b60:c670:0000:0000:0000:0002'
 030504       : Force communication via IP '2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee'
 030504       : #> /usr/bin/wget --hsts-file=/tmp/.wget-hsts -nv -t 1 -O /var/run/ddns/myddns_ipv6.dat -o /var/run/ddns/myddns_ipv6.err --bind-address=2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee --no-proxy 'https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records/d3fec629e04c52c5d7923afaa6654ef0'

curl -X PUT "https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records/d3fec629e04c52c5d7923afaa6654ef0"
    -H "Authorization: Bearer GM98a5m6M7rNKMWu31AU3nx5tfRJi4yGZLuwDFmn"
    -H "Content-Type: application/json"
    --data '{"type":"AAAA","name":"ipv6.ftyiming.us.kg","content":"2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee","ttl":120,"proxied":false}'

curl -X PUT "https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records/5edce1126269d157a5b75f8fda1c384f"
    -H "Authorization: Bearer GM98a5m6M7rNKMWu31AU3nx5tfRJi4yGZLuwDFmn"
    -H "Content-Type: application/json"
    --data '{"type":"AAAA","name":"ipv6.ftyiming.us.kg","content":"2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee","ttl":120,"proxied":false}'

curl -X PUT "https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records/d3fec629e04c52c5d7923afaa6654ef0"
    -H "Authorization: GM98a5m6M7rNKMWu31AU3nx5tfRJi4yGZLuwDFmn"
    -H "Content-Type: application/json"
    --data '{"type":"AAAA","name":"ipv6.ftyiming.us.kg","content":"2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee","ttl":120,"proxied":false}'

你的 Cloudflare API 请求返回了 `81044: Record does not exist`，说明 **Cloudflare 找不到这个 DNS 记录**。可能的原因有：

---

## **1. 确保 `dns_record_id` 正确**

你的 `dns_record_id`（`d3fec629e04c52c5d7923afaa6654ef0`）可能不对，或者这个记录已经被删除。你可以用以下命令获取所有 DNS 记录的 ID，找到正确的 `dns_record_id`：

```sh
curl -X GET "https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records" \
     -H "Authorization: Bearer GM98a5m6M7rNKMWu31AU3nx5tfRJi4yGZLuwDFmn" \
     -H "Content-Type: application/json"
```

### **输出示例**

如果你的 `AAAA` 记录存在，你应该能看到类似的返回：

```json
{
  "result": [
    {
      "id": "new_record_id_123456",
      "type": "AAAA",
      "name": "ipv6.ftyiming.us.kg",
      "content": "2409:8a3c:5b6c:xxxx",
      "ttl": 120
    }
  ],
  "success": true
}
```

找到正确的 `id`，然后更新 API 请求：

```sh
curl -X PUT "https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records/new_record_id_123456" \
     -H "Authorization: Bearer GM98a5m6M7rNKMWu31AU3nx5tfRJi4yGZLuwDFmn" \
     -H "Content-Type: application/json" \
     --data '{"type":"AAAA","name":"ipv6.ftyiming.us.kg","content":"2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee","ttl":120,"proxied":false}'
```

---

## **2. 确保 `AAAA` 记录已经存在**

如果 `GET /dns_records` 没有返回任何 AAAA 记录，说明这个记录不存在，你需要 **新建** 而不是更新：

```sh
curl -X POST "https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records" \
     -H "Authorization: Bearer GM98a5m6M7rNKMWu31AU3nx5tfRJi4yGZLuwDFmn" \
     -H "Content-Type: application/json" \
     --data '{"type":"AAAA","name":"ipv6.ftyiming.us.kg","content":"2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee","ttl":120,"proxied":false}'
```

**成功后 Cloudflare 会返回新的 `id`，然后你才能用 `PUT` 更新。**

---

## **3. 确保 `zone_id` 正确**

你的 `zone_id` 可能不对，可以用下面的命令获取 **你的域名的正确 `zone_id`**：

```sh
curl -X GET "https://api.cloudflare.com/client/v4/zones" \
     -H "Authorization: Bearer GM98a5m6M7rNKMWu31AU3nx5tfRJi4yGZLuwDFmn" \
     -H "Content-Type: application/json"
```

然后检查返回的 `id` 是否和 `17d971746d20de8f4cd3112dbb11d3b6` 一致。

---

## **4. 检查 API Token 权限**

如果你仍然遇到问题，检查 API Token 是否有 **Zone → DNS Edit** 权限，否则无法更新 DNS 记录：

- 进入 [Cloudflare API Tokens](https://dash.cloudflare.com/profile/api-tokens)
- 创建新的 Token，并给它 **Zone:DNS Edit** 权限

---

## **总结**

1. **先用 `GET /dns_records` 确认 `AAAA` 记录的 ID 是否正确**
2. **如果记录不存在，用 `POST` 创建**
3. **检查 `zone_id` 是否正确**
4. **确认 API Token 具有 `Zone:DNS Edit` 权限**

先试试看 `GET /dns_records`，看看 Cloudflare 返回的 `id` 是不是正确的！🚀

root@LEDE:~# curl -X PUT "https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records/5edce1126269d157a5b75f8fda1c384f" \

> -H "Authorization: Bearer GM98a5m6M7rNKMWu31AU3nx5tfRJi4yGZLuwDFmn"
> -H "Content-Type: application/json"
> --data '{"type":"AAAA","name":"ipv6.ftyiming.us.kg","content":"2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee","ttl":120,"proxied":false}'
> {"result":{"id":"5edce1126269d157a5b75f8fda1c384f","name":"ipv6.ftyiming.us.kg","type":"AAAA","content":"2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee","proxiable":true,"proxied":false,"ttl":120,"settings":{},"meta":{},"comment":null,"tags":[],"created_on":"2024-07-27T12:07:39.94685Z","modified_on":"2025-02-09T06:21:45.391595Z"},"success":true,"errors":[],"messages":[]}root@LEDE:~#

213702       : #> /usr/bin/wget --hsts-file=/tmp/.wget-hsts -nv -t 1 -O /var/run/ddns/myddns_ipv6.dat -o /var/run/ddns/myddns_ipv6.err --bind-address=2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee --no-proxy 'https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records/5edce1126269d157a5b75f8fda1c384f'

failed: Address family not supported by protocol.
failed: Operation timed out.

我也是遇到这个错误，昨天花了一个晚上解决了，是wget不支持--bind-address ipv6的问题，我的op版本在/usr/lib/ddns/dynamic_dns_functions.sh中注释掉

#__PROG="$__PROG --bind-address=$__BINDIP"这行就可以了。

其他对应版本找到相应的脚本，注释掉添加--bind-address选项的代码。

你现在遇到的是 `wget` 返回的 **HTTP 400: Bad Request** 错误，通常表示请求格式有问题。之前 `--bind-address` 的问题已经绕过了，但现在可能是  **Cloudflare API 请求格式错误** 。

---

## **1. 确保 API 请求正确**

你当前 `update_url` 是：

```sh
https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records/5edce1126269d157a5b75f8fda1c384f
```

这个 URL  **只适用于 GET 查询** ，但 **更新 DNS 记录** 需要使用 `PUT` 方法，并带上 JSON 数据。

### **正确的 `curl` 命令（Cloudflare API 更新 IPv6 地址）**

在 OpenWrt 里运行：

```sh
curl -X PUT "https://api.cloudflare.com/client/v4/zones/17d971746d20de8f4cd3112dbb11d3b6/dns_records/5edce1126269d157a5b75f8fda1c384f" \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer YOUR_CLOUDFLARE_API_TOKEN" \
     --data '{"type":"AAAA","name":"ipv6.ftyiming.us.kg","content":"2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee","ttl":1,"proxied":false}'
```

 **注意修改 `Authorization` 里的 `YOUR_CLOUDFLARE_API_TOKEN`** ，使用你的  **Cloudflare API 令牌** （需要有 DNS 编辑权限）。

如果 `curl` 返回 `success: true`，表示 API 请求正确。

---

## **2. 修改 OpenWrt DDNS 配置**

你的 `update_url` 直接使用了 `wget`，但 `wget`  **不支持 `PUT` 方法** ，所以需要：

1. **改用 `curl`**
2. **手动拼接 API 请求**

### **修改 `/etc/config/ddns`**

运行：

```sh
vi /etc/config/ddns
```

找到 `config service 'myddns_ipv6'` 部分，修改：

```sh
option use_curl '1'
option update_url 'https://api.cloudflare.com/client/v4/zones/YOUR_ZONE_ID/dns_records/YOUR_RECORD_ID'
option update_script '/usr/lib/ddns/update_cloudflare.sh'
```

/usr/lib/ddns/update_cloudflare.sh

脚本路径没了

然后创建 `update_cloudflare.sh` 脚本：

```sh
vi /usr/lib/ddns/update_cloudflare.sh
```

内容：

```sh
#!/bin/sh
CLOUDFLARE_API_TOKEN="你的 API 令牌"
ZONE_ID="17d971746d20de8f4cd3112dbb11d3b6"
RECORD_ID="5edce1126269d157a5b75f8fda1c384f"
IPV6_ADDR="$1"

curl -X PUT "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$RECORD_ID" \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
     --data "{\"type\":\"AAAA\",\"name\":\"ipv6.ftyiming.us.kg\",\"content\":\"$IPV6_ADDR\",\"ttl\":1,\"proxied\":false}"
```

然后赋予可执行权限：

```sh
chmod +x /usr/lib/ddns/update_cloudflare.sh
```

---

## **3. 重启 DDNS**

```sh
/etc/init.d/ddns restart
```

然后检查日志：

```sh
logread -e ddns
```

如果返回 `success: true`，说明 Cloudflare 更新成功！🎉

---

### **总结**

* `wget`  **不支持 PUT 请求** ，导致 400 错误
* `curl`  **可以发送 JSON 数据** ，用它来更新 Cloudflare
* **修改 OpenWrt DDNS 配置** ，让它调用 `update_cloudflare.sh`
* **手动测试 `curl` 命令** 确保 API 令牌和请求格式正确

这样应该就能成功更新 IPv6 记录了！🚀

220128  note : PID '8503' started at 2025-02-09 22:01
 220128       : ddns version  : 2.8.2-52
 220128       : uci configuration:
ddns.myddns_ipv6.check_interval='1'
ddns.myddns_ipv6.check_unit='hours'
ddns.myddns_ipv6.domain='ftyiming.us.kg'
ddns.myddns_ipv6.enabled='1'
ddns.myddns_ipv6.force_interval='24'
ddns.myddns_ipv6.force_unit='hours'
ddns.myddns_ipv6.interface='wan6'
ddns.myddns_ipv6.ip_network='wan6'
ddns.myddns_ipv6.ip_source='network'
ddns.myddns_ipv6.lookup_host='ipv6.ftyiming.us.kg'
ddns.myddns_ipv6.password='***PW***'
ddns.myddns_ipv6.retry_interval='5'
ddns.myddns_ipv6.retry_max_count='1'
ddns.myddns_ipv6.retry_unit='seconds'
ddns.myddns_ipv6.update_script='/usr/lib/ddns/update_cloudflare.sh'
ddns.myddns_ipv6.update_url='https://api.cloudflare.com/client/v4/zones/YOUR_ZONE_ID/dns_records/YOUR_RECORD_ID'
ddns.myddns_ipv6.use_curl='1'
ddns.myddns_ipv6.use_ipv6='1'
ddns.myddns_ipv6.use_syslog='2'
ddns.myddns_ipv6.username='ftyiming@outlook.com'
ddns.myddns_ipv6=service
 220128       : verbose mode  : 0 - run normal, NO console output
 220128       : check interval: 3600 seconds
 220128       : force interval: 86400 seconds
 220128       : retry interval: 5 seconds
 220128       : retry max count : 1 times
 220128       : No old process
 220128       : last update: never
 220128       : Detect registered/public IP
 220128       : #> /usr/bin/nslookup ipv6.ftyiming.us.kg  >/var/run/ddns/myddns_ipv6.dat 2>/var/run/ddns/myddns_ipv6.err
 220131       : Registered IP '2409:8a3c:5b60:c670::2' detected
 220131  info : Starting main loop at 2025-02-09 22:01
 220131       : Detect current IP on 'network'
 220131       : Current IP '2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee' detected on network 'wan6'
 220131       : Update needed - L: '2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee' <> R: '2409:8a3c:5b60:c670:0000:0000:0000:0002'
 220131       : parsing script '/usr/lib/ddns/update_cloudflare.sh'
 220133  info : Update successful - IP '2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee' send
 220133  info : Forced update successful - IP: '2409:8a3c:5b6c:d540:3ecd:57ff:fe6a:b0ee' send
 220133       : Waiting 3600 seconds (Check Interval)

成功了？

### **3. 彻底屏蔽 `wget`，只允许 `curl`**

如果 `wget` 仍然在日志中报错，可以用  **软链接屏蔽 `wget`** ：

mv /usr/bin/wget /usr/bin/wget.bak
ln -s /usr/bin/curl /usr/bin/wget

logread -e ddns

opkg update

防火墙  和 管理权限




## shell openwrt 上路

ip -6 neigh show


在 OpenWrt 上，`uhttpd` 是默认的 Web 服务器（用于 LuCI 管理界面），如果你想查看登录日志，可以参考以下方法：

---

### **1. 查看 uhttpd 相关日志**

`uhttpd` 默认不会单独记录访问日志，但你可以通过 `logread` 过滤相关日志：

```sh
logread | grep uhttpd
```

如果想实时监控：

```sh
logread -f | grep uhttpd
```

---

### **2. 查看 LuCI 登录日志**

LuCI 登录认证失败或成功的日志通常存储在 `logread` 里，使用：

```sh
logread | grep -i luci
```

如果你想筛选出失败的尝试：

```sh
logread | grep -i 'failed\|invalid'
```

常见的日志示例：

```
Jan 26 12:34:56 LEDE authpriv.notice uhttpd[1234]: Failed login attempt for root from 192.168.1.100
Jan 26 12:35:10 LEDE authpriv.notice uhttpd[1234]: Successful login for root from 192.168.1.100
```

这样你可以看到哪些 IP 访问了 LuCI，是否有失败的尝试。

---

### **3. 启用 uhttpd 访问日志**

默认情况下，`uhttpd`  **不会记录访问日志** ，但你可以手动启用它：

1. 编辑 `uhttpd` 配置文件：
   ```sh
   vi /etc/config/uhttpd
   ```
2. 找到 `option log`，如果没有，添加：
   ```sh
   option log '/var/log/uhttpd.log'
   ```
3. 重新启动 `uhttpd`：
   ```sh
   /etc/init.d/uhttpd restart
   ```

然后你可以使用：

```sh
tail -f /var/log/uhttpd.log
```

来查看 Web 访问日志。

---

### **4. 结合 iptables 监控 LuCI 访问**

如果你想监控谁访问了 LuCI（80/443 端口），可以用 `iptables` 记录：

```sh
iptables -I INPUT -p tcp --dport 80 -j LOG --log-prefix "LUCI_ACCESS: "
iptables -I INPUT -p tcp --dport 443 -j LOG --log-prefix "LUCI_ACCESS: "
```

然后使用：

```sh
dmesg | grep LUCI_ACCESS
```

logread | grep -i 'failed\|invalid'


在 LEDE（OpenWrt）上，将 DNS 解析服务器指定为 `192.168.1.1`，可以通过以下几种方式进行配置：

---

## **方法 1：修改 `resolv.conf`（临时生效）**
你可以手动编辑 `/etc/resolv.conf`，指定 `192.168.1.1` 为 DNS 服务器：
```sh
echo "nameserver 192.168.1.1" > /etc/resolv.conf
```
但 **这种方法会在设备重启或网络重连时被覆盖**，所以推荐使用方法 2 或 3。

---

## **方法 2：使用 `uci` 配置（推荐，永久生效）**
修改 OpenWrt 的 `network` 配置，指定 `192.168.1.1` 作为 DNS 服务器：

```sh
uci set network.wan.peerdns='0'        # 禁用自动获取 DNS
uci set network.wan.dns='192.168.1.1'  # 设置自定义 DNS
uci commit network
/etc/init.d/network restart            # 重启网络使配置生效
```
然后检查 `/etc/resolv.conf` 是否已正确更新：
```sh
cat /etc/resolv.conf
```

## 方法无效

 
---

## **方法 3：配置 `dnsmasq`（如果你想让本机 `dnsmasq` 解析时使用 192.168.1.1）**
如果你希望 LEDE 的 `dnsmasq` 代理 DNS 查询到 `192.168.1.1`，可以修改 `/etc/config/dhcp`：
```sh
uci set dhcp.@dnsmasq[0].server='192.168.1.1'
uci commit dhcp
/etc/init.d/dnsmasq restart
```

然后测试：
```sh
nslookup ipv6.ftyiming.us.kg 192.168.1.1
```

---

## **验证**
执行以下命令，确认 DNS 解析是否走 `192.168.1.1`：
```sh
nslookup ipv6.ftyiming.us.kg
```
或者：
```sh
cat /etc/resolv.conf
```

如果 `resolv.conf` 显示 `nameserver 192.168.1.1`，说明配置成功。

**总结**
- **方法 1** 适用于临时测试，重启会失效。
- **方法 2** 适用于 WAN 口，避免 DHCP 获取其他 DNS。
- **方法 3** 适用于 `dnsmasq`，让 LEDE 本地 DNS 解析使用 `192.168.1.1`。

**推荐方法 2 或 3，根据你的需求选择！**